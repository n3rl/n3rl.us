<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Hanzi</title>
  <style>
    #canvas {
      border: 1px solid black;
      touch-action: none;
    }
    #controls {
      margin-top: 10px;
    }
	
	#wrapper {
  position: relative;
  width: 300px;
  height: 300px;
}



  </style>
</head>
<body>
<h3>hanzi</h3>
<span id="question"></span>
<div>
  <button id="pinyinBtn">Show pinyin</button>
  <span id="pinyin"></span>
</div>
<input id="characterEntry" type="text" maxlength="1">
<button id="submitBtn">Submit</button>
<div id="wrapper">
	<canvas id="canvas" width="300" height="300"></canvas>
	<embed id="animation" src="./common_svgs/æˆ‘.svg" type="image/svg+xml" style="visibility:hidden; position:absolute; top:0; left:0; width:300px; height:300px; pointer-events:none; opacity:0.3;">
</div>
<div id="controls">
  <button id="checkBtn">Check</button>
  <button id="clearBtn">Clear</button>
  <button id="undoBtn">Undo</button>
  <button id="replayBtn">Replay</button>
  <input id="showChr" type="checkbox"> show/hide character
</div>

<div id="result"></div>

<script src="hanzilookup.min.js"></script>
<script src="https://unpkg.com/pinyin-pro"></script>

<script>
const { pinyin } = pinyinPro;

  // Track strokes
  let resultEl = document.getElementById("result")
  
  let strokes = [];
  let currentStroke = [];
  let drawing = false;

  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  	ctx.lineWidth = 10;
	ctx.lineCap = 'round';


function drawGrid() {
  const w = canvas.width;
  const h = canvas.height;

  ctx.save();
  ctx.strokeStyle = "#cccccc";
  ctx.lineWidth = 1;

  ctx.clearRect(0, 0, w, h);

  ctx.strokeRect(0, 0, w, h);

  ctx.beginPath();
  ctx.moveTo(w / 2, 0);
  ctx.lineTo(w / 2, h);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(0, h / 2);
  ctx.lineTo(w, h / 2);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(w, h);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(w, 0);
  ctx.lineTo(0, h);
  ctx.stroke();

  ctx.restore();
}

drawGrid();


  // Get pointer position relative to canvas
  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    if (e.touches) e = e.touches[0];
    return [e.clientX - rect.left, e.clientY - rect.top];
  }

  // Pointer events
  canvas.addEventListener("pointerdown", e => {
    drawing = true;
    currentStroke = [];
    const pos = getPos(e);
    currentStroke.push(pos);
    ctx.beginPath();
    ctx.moveTo(...pos);
    canvas.setPointerCapture(e.pointerId);
  });

  canvas.addEventListener("pointermove", e => {
    if (!drawing) return;
    const pos = getPos(e);
    currentStroke.push(pos);
    ctx.lineTo(...pos);
    ctx.stroke();
  });

  canvas.addEventListener("pointerup", e => {
    if (drawing && currentStroke.length > 1) strokes.push(currentStroke);
    drawing = false;
	recognize();
  });

  canvas.addEventListener("pointerleave", e => {
    if (drawing && currentStroke.length) strokes.push(currentStroke);
    drawing = false;
  });

  // Clear button
document.getElementById("replayBtn").onclick = function() {
  const svg = document.getElementById("animation");
  const url = svg.getAttribute("src");
  svg.setAttribute("src", url);
};

document.getElementById("undoBtn").onclick = () => {
  if (strokes.length === 0) return;       // nothing to undo
  strokes.pop();                          // remove last stroke
  ctx.clearRect(0, 0, canvas.width, canvas.height);  // clear canvas
  drawGrid();                              // redraw grid

  // redraw remaining strokes
  ctx.beginPath();
  for (let stroke of strokes) {
    if (stroke.length === 0) continue;
    ctx.moveTo(...stroke[0]);
    for (let i = 1; i < stroke.length; i++) {
      ctx.lineTo(...stroke[i]);
    }
  }
  ctx.stroke();

  if (strokes.length === 0) {
    resultEl.innerText = '';
	return;
  }
  recognize();
};

function cleardraw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  strokes = [];
  drawGrid();
  resultEl.innerText = ''; 
};

document.getElementById("clearBtn").onclick = cleardraw;

document.getElementById("submitBtn").onclick = async () => {
  const chr = document.getElementById("characterEntry").value
  const path = `./common_svgs/${chr}.svg`;

  try {
    const res = await fetch(path, { method: "HEAD" });
    if (res.ok) {
      document.getElementById("animation").setAttribute("src", path);
    } else {
      console.log("SVG not found:", path);
    }
  } catch {
    console.log("Error fetching:", path);
  }
}


let matcher = null;

HanziLookup.init('mmah','mmah.json', success => {
  if (!success) { 
    resultEl.innerText = 'Failed to load MMAH data'; 
    return; 
  }
  
  matcher = new HanziLookup.Matcher('mmah');
});

function recognize() {
  const analyzed = new HanziLookup.AnalyzedCharacter(strokes);

  matcher.match(analyzed, 1, matches => {
    if (!matches.length) { 
      resultEl.innerText = 'No matches'; 
      return; 
    }
    resultEl.innerText = `${matches[0]['character']} (score: ${matches[0]['score'].toFixed(3)})`;
  });
}

async function loadShuffledQuestions(url) {
    const resp = await fetch(url);
    const text = await resp.text();
    let lines = text.split(/\r?\n/).filter(x => x.trim());
	lines = lines.map(l => l.split("|"));


    for (let i = lines.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = lines[i];
        lines[i] = lines[j];
        lines[j] = tmp;
    }

    return lines;
}

async function init() {
	const questions = await loadShuffledQuestions("questions.csv");
    console.log(questions);
	let index = 0;
    function nextQuestion() {
        if (index > questions.length) return null;
        const q = questions[index];
        index += 1;
        return q;
    }
	
	function setupQuestion() {
	    const next = nextQuestion();
        if (next) {
            ([question, answer] = next);
            console.log(answer);
        }
		cleardraw();
		document.getElementById("question").innerText = question;
		document.getElementById("showChr").checked = false;
		document.getElementById("pinyin").innerText = '';
	};
	
	setupQuestion();
	
	document.getElementById("checkBtn").onclick = function() {
      const resultEl = document.getElementById("result");
      if (resultEl.innerText[0] === answer) {
        console.log("success!")
		setupQuestion();
      }
	};

	document.getElementById("pinyinBtn").onclick = function() {
      const pinyinEl = document.getElementById("pinyin");
      pinyinEl.innerText = pinyin(answer, { tone: true });
	};

	document.getElementById("showChr").addEventListener("change", function() {
	  const anim = document.getElementById("animation");
	  if (this.checked) {
		anim.style.visibility = "visible";
		const svg = document.getElementById("animation");
		svg.setAttribute("src", `./common_svgs/${answer}.svg`);
	  } else {
		anim.style.visibility = "hidden";
	  }
	});
	
}

init();
</script>

</body>
</html>
