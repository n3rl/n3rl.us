<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Hanzi</title>
<style>
  body { font-family: system-ui, Arial, sans-serif; background:#efe8da; margin:20px; }
  #frame { display:flex; gap:18px; align-items:flex-start; }
  canvas { border:1px solid #bfb6aa; background: #f8f3e8; touch-action:none; }
  #ui { width:300px; }
  #controls { margin-top:12px; display:flex; gap:8px; }
  #result { margin-top:12px; color:#222; }
</style>
</head>

<body>
<div id="frame">
  <canvas id="paper" width="420" height="420"></canvas>
</div>
<div id="ui">
  <div id="controls">
    <button id="clearBtn">Clear</button>
    <button id="undoBtn">Undo</button>
    <button id="checkBtn">Check</button>
  </div>
  <div id="result"></div>
</div>

<script src="hanzilookup.min.js"></script>

<script>
/* ======= Brush rendering system ======= */
const paper = document.getElementById('paper');
const ctx = paper.getContext('2d', {alpha:true});
const W = paper.width, H = paper.height;

/* Offscreen canvases */
const inkCanvas = document.createElement('canvas');
inkCanvas.width = W; inkCanvas.height = H;
const inkCtx = inkCanvas.getContext('2d');

const blendCanvas = document.createElement('canvas');
blendCanvas.width = W; blendCanvas.height = H;
const blendCtx = blendCanvas.getContext('2d');

function drawGrid() {
  const w = blendCanvas.width;
  const h = blendCanvas.height;

  ctx.save();
  ctx.strokeStyle = "#cccccc";
  ctx.lineWidth = 1;

  ctx.clearRect(0, 0, w, h);

  ctx.strokeRect(0, 0, w, h);

  ctx.beginPath();
  ctx.moveTo(w / 2, 0);
  ctx.lineTo(w / 2, h);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(0, h / 2);
  ctx.lineTo(w, h / 2);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(w, h);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(w, 0);
  ctx.lineTo(0, h);
  ctx.stroke();

  ctx.restore();
}

drawGrid();

/* stroke data */
let strokes = [];        // array of strokes; each stroke is [{x,y,t,force}]
let current = null;

/* pointer handling */
paper.style.touchAction = 'none';
paper.addEventListener('pointerdown', pointerDown);
paper.addEventListener('pointermove', pointerMove);
paper.addEventListener('pointerup', pointerUp);
paper.addEventListener('pointercancel', pointerUp);

function posFromEvent(e) {
  const r = paper.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top, t: performance.now(), force: e.pressure || (e.force||0) || 0 };
}

/* compute unit normal for segment p->q */
function normal(p,q) {
  const dx = q.x - p.x, dy = q.y - p.y;
  const len = Math.hypot(dx,dy) || 1;
  return { nx: -dy/len, ny: dx/len };
}

/* compute width from velocity and pressure */
function widthForSegment(v, pressure) {
  const minW = 3, maxW = 28;
  const speed = Math.min(v, 4); // clamp
  const wFromSpeed = maxW - (speed/3)*(maxW - minW);
  const p = Math.max(pressure || 0, 0);
  // stylus pressure increases width multiplicatively
  return Math.max(minW, Math.min(maxW, wFromSpeed * (0.9 + 0.6 * p)));
}

/* sample smoothing (simple moving average) */
function smoothPoints(pts, span=2) {
  if (pts.length<=2) return pts.slice();
  const out = [];
  for (let i=0;i<pts.length;i++) {
    let sx=0, sy=0, st=0, sf=0, n=0;
    for (let j=Math.max(0,i-span); j<=Math.min(pts.length-1,i+span); j++) {
      sx += pts[j].x; sy += pts[j].y; st += pts[j].t; sf += (pts[j].force||0); n++;
    }
    out.push({x:sx/n,y:sy/n,t:st/n,force:sf/n});
  }
  return out;
}

/* build ribbon polygon from points */
function buildRibbon(pts) {
  if (pts.length<2) return null;
  const left = [], right = [];
  for (let i=0;i<pts.length;i++) {
    const p = pts[i];
    const prev = pts[Math.max(0,i-1)];
    const dt = Math.max(1, p.t - prev.t);
    const dx = p.x - prev.x, dy = p.y - prev.y;
    const v = Math.hypot(dx,dy)/dt;
    const w = widthForSegment(v, p.force);

    // directional normal
    const q = pts[Math.min(i+1, pts.length-1)];
    const nrm = normal(prev, q);
    left.push({x: p.x + nrm.nx * w/2, y: p.y + nrm.ny * w/2});
    right.push({x: p.x - nrm.nx * w/2, y: p.y - nrm.ny * w/2});
  }
  // endcaps smoothing: create tapering by shrinking width near ends
  return {left, right, pts};
}

/* draw ribbon to inkCtx with ink texture */
function drawRibbon(ribbon) {
  if (!ribbon) return;
  const L = ribbon.left, R = ribbon.right;
  inkCtx.save();
  inkCtx.globalCompositeOperation = 'source-over';
  inkCtx.fillStyle = '#000';
  inkCtx.beginPath();
  inkCtx.moveTo(L[0].x, L[0].y);
  for (let p of L) inkCtx.lineTo(p.x, p.y);
  for (let i=R.length-1;i>=0;i--) inkCtx.lineTo(R[i].x, R[i].y);
  inkCtx.closePath();

  // subtle inner gradient to simulate brush ink density
  const bbox = boundingBox(L.concat(R));
  const grad = inkCtx.createRadialGradient((bbox.x+bbox.x2)/2,(bbox.y+bbox.y2)/2,1,(bbox.x+bbox.x2)/2,(bbox.y+bbox.y2)/2, Math.max(bbox.w,bbox.h));
  grad.addColorStop(0,'rgba(0,0,0,0.95)');
  grad.addColorStop(0.4,'rgba(0,0,0,0.85)');
  grad.addColorStop(1,'rgba(0,0,0,0.65)');
  inkCtx.fillStyle = grad;
  inkCtx.fill();

  // add grainy ink texture inside the ribbon
  const img = inkCtx.getImageData(bbox.x,bbox.y,bbox.w,bbox.h);
  for (let i=0;i<img.data.length;i+=4) {
    const alpha = img.data[i+3];
    if (alpha>10) {
      const jitter = (Math.random()-0.5)*38;
      img.data[i+0] = Math.max(0, img.data[i+0] + jitter);
      img.data[i+1] = Math.max(0, img.data[i+1] + jitter);
      img.data[i+2] = Math.max(0, img.data[i+2] + jitter);
      img.data[i+3] = Math.min(255, alpha - (Math.random()*24));
    }
  }
  inkCtx.putImageData(img, bbox.x, bbox.y);

  inkCtx.restore();
}

/* bounding box helper */
function boundingBox(points) {
  const xs = points.map(p=>p.x), ys = points.map(p=>p.y);
  const x = Math.floor(Math.min(...xs)), y = Math.floor(Math.min(...ys));
  const x2 = Math.ceil(Math.max(...xs)), y2 = Math.ceil(Math.max(...ys));
  return {x, y, x2, y2, w: Math.max(1,x2-x), h: Math.max(1,y2-y)};
}

/* composite ink onto paper: multiply blending + slight blur to simulate soak */
function compositeInk() {
  // draw inkCanvas over paper with multiply
  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  ctx.drawImage(inkCanvas, 0, 0);
  ctx.restore();

  // slight blur/feather using drawImage scaling trick as cheap diffusion
  // create a temporary scaled copy and draw with low alpha to bleed edges
  blendCtx.clearRect(0,0,W,H);
  blendCtx.globalAlpha = 0.2;
  blendCtx.filter = 'blur(2px)';
  blendCtx.drawImage(inkCanvas,0,0);
  blendCtx.filter = 'none';
  ctx.globalAlpha = 0.18;
  ctx.drawImage(blendCanvas, 0, 0);
  ctx.globalAlpha = 1.0;
}

/* render all strokes (clear paper base then composite) */
function redrawAll() {
  // regenerate paper base and then composite all ink
  inkCtx.clearRect(0,0,W,H);
  for (const s of strokes) {
    const sm = smoothPoints(s,1);
    const ribbon = buildRibbon(sm);
    drawRibbon(ribbon);
  }
  compositeInk();
}

/* capture pointers */
function pointerDown(e) {
  e.preventDefault();
  paper.setPointerCapture(e.pointerId);
  current = [];
  const p = posFromEvent(e);
  current.push(p);
  lastTime = p.t;
  lastPos = p;
}
function pointerMove(e) {
  if (!current) return;
  const p = posFromEvent(e);
  // basic downsample by time to reduce noise
  if (p.t - current[current.length-1].t < 4) return;
  current.push(p);

  // render incremental to inkCtx then composite one segment to display for responsiveness
  inkCtx.clearRect(0,0,W,H);
  // render previous strokes lightly for preview
  for (const s of strokes) {
    const sm = smoothPoints(s,1);
    drawRibbon(buildRibbon(sm));
  }
  // also draw current stroke so far
  const smc = smoothPoints(current,1);
  drawRibbon(buildRibbon(smc));
  // composite into main canvas for live feedback (without committing to strokes array)
  ctx.drawImage(inkCanvas,0,0);
}
function pointerUp(e) {
  if (!current) return;
  // commit stroke
  strokes.push(current.slice());
  current = null;
  // render final
  redrawAll();
  paper.releasePointerCapture(e.pointerId);
}

/* undo/clear */
document.getElementById('clearBtn').onclick = () => { strokes = []; current = null; drawGrid();};
document.getElementById('undoBtn').onclick = () => { strokes.pop(); redrawAll(); };

/* ===== HanziLookup integration (unchanged) ===== */
const resultEl = document.getElementById('result');
HanziLookup.init('mmah','mmah.json', success => {
  if (!success) { resultEl.innerText = 'Failed to load MMAH data'; return; }
  const matcher = new HanziLookup.Matcher('mmah');
  document.getElementById('checkBtn').onclick = () => {
    if (!strokes.length) { resultEl.innerText = 'Draw first'; return; }
    // convert strokes to the format HanziLookup expects: array of strokes->array of [x,y]
    const approx = strokes.map(s => s.map(p => [p.x, p.y]));
    const analyzed = new HanziLookup.AnalyzedCharacter(approx);
    matcher.match(analyzed, 6, matches => {
      if (!matches.length) { resultEl.innerText = 'No matches'; return; }
      resultEl.innerText = 'Matches: ' + matches.map(m=>m.character).join(' ');
    });
  };
});

</script>
</body>
</html>
